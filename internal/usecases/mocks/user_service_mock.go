// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/neracastle/auth/internal/usecases.UserService -o user_service_mock.go -n UserServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	def "github.com/neracastle/auth/internal/usecases/models"
)

// UserServiceMock implements usecases.UserService
type UserServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAuth          func(ctx context.Context, login string, pwd string) (a1 def.AuthTokens, err error)
	inspectFuncAuth   func(ctx context.Context, login string, pwd string)
	afterAuthCounter  uint64
	beforeAuthCounter uint64
	AuthMock          mUserServiceMockAuth

	funcCanDelete          func(ctx context.Context, userID int64) (b1 bool)
	inspectFuncCanDelete   func(ctx context.Context, userID int64)
	afterCanDeleteCounter  uint64
	beforeCanDeleteCounter uint64
	CanDeleteMock          mUserServiceMockCanDelete

	funcCreate          func(ctx context.Context, req def.CreateDTO) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, req def.CreateDTO)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mUserServiceMockCreate

	funcDelete          func(ctx context.Context, userID int64) (err error)
	inspectFuncDelete   func(ctx context.Context, userID int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mUserServiceMockDelete

	funcGet          func(ctx context.Context, userID int64) (u1 def.UserDTO, err error)
	inspectFuncGet   func(ctx context.Context, userID int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mUserServiceMockGet

	funcRenewal          func(ctx context.Context, refreshToken string, isRenewAccess bool) (s1 string, err error)
	inspectFuncRenewal   func(ctx context.Context, refreshToken string, isRenewAccess bool)
	afterRenewalCounter  uint64
	beforeRenewalCounter uint64
	RenewalMock          mUserServiceMockRenewal

	funcUpdate          func(ctx context.Context, user def.UpdateDTO) (err error)
	inspectFuncUpdate   func(ctx context.Context, user def.UpdateDTO)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mUserServiceMockUpdate
}

// NewUserServiceMock returns a mock for usecases.UserService
func NewUserServiceMock(t minimock.Tester) *UserServiceMock {
	m := &UserServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AuthMock = mUserServiceMockAuth{mock: m}
	m.AuthMock.callArgs = []*UserServiceMockAuthParams{}

	m.CanDeleteMock = mUserServiceMockCanDelete{mock: m}
	m.CanDeleteMock.callArgs = []*UserServiceMockCanDeleteParams{}

	m.CreateMock = mUserServiceMockCreate{mock: m}
	m.CreateMock.callArgs = []*UserServiceMockCreateParams{}

	m.DeleteMock = mUserServiceMockDelete{mock: m}
	m.DeleteMock.callArgs = []*UserServiceMockDeleteParams{}

	m.GetMock = mUserServiceMockGet{mock: m}
	m.GetMock.callArgs = []*UserServiceMockGetParams{}

	m.RenewalMock = mUserServiceMockRenewal{mock: m}
	m.RenewalMock.callArgs = []*UserServiceMockRenewalParams{}

	m.UpdateMock = mUserServiceMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*UserServiceMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserServiceMockAuth struct {
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockAuthExpectation
	expectations       []*UserServiceMockAuthExpectation

	callArgs []*UserServiceMockAuthParams
	mutex    sync.RWMutex
}

// UserServiceMockAuthExpectation specifies expectation struct of the UserService.Auth
type UserServiceMockAuthExpectation struct {
	mock    *UserServiceMock
	params  *UserServiceMockAuthParams
	results *UserServiceMockAuthResults
	Counter uint64
}

// UserServiceMockAuthParams contains parameters of the UserService.Auth
type UserServiceMockAuthParams struct {
	ctx   context.Context
	login string
	pwd   string
}

// UserServiceMockAuthResults contains results of the UserService.Auth
type UserServiceMockAuthResults struct {
	a1  def.AuthTokens
	err error
}

// Expect sets up expected params for UserService.Auth
func (mmAuth *mUserServiceMockAuth) Expect(ctx context.Context, login string, pwd string) *mUserServiceMockAuth {
	if mmAuth.mock.funcAuth != nil {
		mmAuth.mock.t.Fatalf("UserServiceMock.Auth mock is already set by Set")
	}

	if mmAuth.defaultExpectation == nil {
		mmAuth.defaultExpectation = &UserServiceMockAuthExpectation{}
	}

	mmAuth.defaultExpectation.params = &UserServiceMockAuthParams{ctx, login, pwd}
	for _, e := range mmAuth.expectations {
		if minimock.Equal(e.params, mmAuth.defaultExpectation.params) {
			mmAuth.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAuth.defaultExpectation.params)
		}
	}

	return mmAuth
}

// Inspect accepts an inspector function that has same arguments as the UserService.Auth
func (mmAuth *mUserServiceMockAuth) Inspect(f func(ctx context.Context, login string, pwd string)) *mUserServiceMockAuth {
	if mmAuth.mock.inspectFuncAuth != nil {
		mmAuth.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Auth")
	}

	mmAuth.mock.inspectFuncAuth = f

	return mmAuth
}

// Return sets up results that will be returned by UserService.Auth
func (mmAuth *mUserServiceMockAuth) Return(a1 def.AuthTokens, err error) *UserServiceMock {
	if mmAuth.mock.funcAuth != nil {
		mmAuth.mock.t.Fatalf("UserServiceMock.Auth mock is already set by Set")
	}

	if mmAuth.defaultExpectation == nil {
		mmAuth.defaultExpectation = &UserServiceMockAuthExpectation{mock: mmAuth.mock}
	}
	mmAuth.defaultExpectation.results = &UserServiceMockAuthResults{a1, err}
	return mmAuth.mock
}

// Set uses given function f to mock the UserService.Auth method
func (mmAuth *mUserServiceMockAuth) Set(f func(ctx context.Context, login string, pwd string) (a1 def.AuthTokens, err error)) *UserServiceMock {
	if mmAuth.defaultExpectation != nil {
		mmAuth.mock.t.Fatalf("Default expectation is already set for the UserService.Auth method")
	}

	if len(mmAuth.expectations) > 0 {
		mmAuth.mock.t.Fatalf("Some expectations are already set for the UserService.Auth method")
	}

	mmAuth.mock.funcAuth = f
	return mmAuth.mock
}

// When sets expectation for the UserService.Auth which will trigger the result defined by the following
// Then helper
func (mmAuth *mUserServiceMockAuth) When(ctx context.Context, login string, pwd string) *UserServiceMockAuthExpectation {
	if mmAuth.mock.funcAuth != nil {
		mmAuth.mock.t.Fatalf("UserServiceMock.Auth mock is already set by Set")
	}

	expectation := &UserServiceMockAuthExpectation{
		mock:   mmAuth.mock,
		params: &UserServiceMockAuthParams{ctx, login, pwd},
	}
	mmAuth.expectations = append(mmAuth.expectations, expectation)
	return expectation
}

// Then sets up UserService.Auth return parameters for the expectation previously defined by the When method
func (e *UserServiceMockAuthExpectation) Then(a1 def.AuthTokens, err error) *UserServiceMock {
	e.results = &UserServiceMockAuthResults{a1, err}
	return e.mock
}

// Auth implements usecases.UserService
func (mmAuth *UserServiceMock) Auth(ctx context.Context, login string, pwd string) (a1 def.AuthTokens, err error) {
	mm_atomic.AddUint64(&mmAuth.beforeAuthCounter, 1)
	defer mm_atomic.AddUint64(&mmAuth.afterAuthCounter, 1)

	if mmAuth.inspectFuncAuth != nil {
		mmAuth.inspectFuncAuth(ctx, login, pwd)
	}

	mm_params := UserServiceMockAuthParams{ctx, login, pwd}

	// Record call args
	mmAuth.AuthMock.mutex.Lock()
	mmAuth.AuthMock.callArgs = append(mmAuth.AuthMock.callArgs, &mm_params)
	mmAuth.AuthMock.mutex.Unlock()

	for _, e := range mmAuth.AuthMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1, e.results.err
		}
	}

	if mmAuth.AuthMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAuth.AuthMock.defaultExpectation.Counter, 1)
		mm_want := mmAuth.AuthMock.defaultExpectation.params
		mm_got := UserServiceMockAuthParams{ctx, login, pwd}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAuth.t.Errorf("UserServiceMock.Auth got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAuth.AuthMock.defaultExpectation.results
		if mm_results == nil {
			mmAuth.t.Fatal("No results are set for the UserServiceMock.Auth")
		}
		return (*mm_results).a1, (*mm_results).err
	}
	if mmAuth.funcAuth != nil {
		return mmAuth.funcAuth(ctx, login, pwd)
	}
	mmAuth.t.Fatalf("Unexpected call to UserServiceMock.Auth. %v %v %v", ctx, login, pwd)
	return
}

// AuthAfterCounter returns a count of finished UserServiceMock.Auth invocations
func (mmAuth *UserServiceMock) AuthAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAuth.afterAuthCounter)
}

// AuthBeforeCounter returns a count of UserServiceMock.Auth invocations
func (mmAuth *UserServiceMock) AuthBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAuth.beforeAuthCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Auth.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAuth *mUserServiceMockAuth) Calls() []*UserServiceMockAuthParams {
	mmAuth.mutex.RLock()

	argCopy := make([]*UserServiceMockAuthParams, len(mmAuth.callArgs))
	copy(argCopy, mmAuth.callArgs)

	mmAuth.mutex.RUnlock()

	return argCopy
}

// MinimockAuthDone returns true if the count of the Auth invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockAuthDone() bool {
	for _, e := range m.AuthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AuthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAuthCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAuth != nil && mm_atomic.LoadUint64(&m.afterAuthCounter) < 1 {
		return false
	}
	return true
}

// MinimockAuthInspect logs each unmet expectation
func (m *UserServiceMock) MinimockAuthInspect() {
	for _, e := range m.AuthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Auth with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AuthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAuthCounter) < 1 {
		if m.AuthMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.Auth")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Auth with params: %#v", *m.AuthMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAuth != nil && mm_atomic.LoadUint64(&m.afterAuthCounter) < 1 {
		m.t.Error("Expected call to UserServiceMock.Auth")
	}
}

type mUserServiceMockCanDelete struct {
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockCanDeleteExpectation
	expectations       []*UserServiceMockCanDeleteExpectation

	callArgs []*UserServiceMockCanDeleteParams
	mutex    sync.RWMutex
}

// UserServiceMockCanDeleteExpectation specifies expectation struct of the UserService.CanDelete
type UserServiceMockCanDeleteExpectation struct {
	mock    *UserServiceMock
	params  *UserServiceMockCanDeleteParams
	results *UserServiceMockCanDeleteResults
	Counter uint64
}

// UserServiceMockCanDeleteParams contains parameters of the UserService.CanDelete
type UserServiceMockCanDeleteParams struct {
	ctx    context.Context
	userID int64
}

// UserServiceMockCanDeleteResults contains results of the UserService.CanDelete
type UserServiceMockCanDeleteResults struct {
	b1 bool
}

// Expect sets up expected params for UserService.CanDelete
func (mmCanDelete *mUserServiceMockCanDelete) Expect(ctx context.Context, userID int64) *mUserServiceMockCanDelete {
	if mmCanDelete.mock.funcCanDelete != nil {
		mmCanDelete.mock.t.Fatalf("UserServiceMock.CanDelete mock is already set by Set")
	}

	if mmCanDelete.defaultExpectation == nil {
		mmCanDelete.defaultExpectation = &UserServiceMockCanDeleteExpectation{}
	}

	mmCanDelete.defaultExpectation.params = &UserServiceMockCanDeleteParams{ctx, userID}
	for _, e := range mmCanDelete.expectations {
		if minimock.Equal(e.params, mmCanDelete.defaultExpectation.params) {
			mmCanDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCanDelete.defaultExpectation.params)
		}
	}

	return mmCanDelete
}

// Inspect accepts an inspector function that has same arguments as the UserService.CanDelete
func (mmCanDelete *mUserServiceMockCanDelete) Inspect(f func(ctx context.Context, userID int64)) *mUserServiceMockCanDelete {
	if mmCanDelete.mock.inspectFuncCanDelete != nil {
		mmCanDelete.mock.t.Fatalf("Inspect function is already set for UserServiceMock.CanDelete")
	}

	mmCanDelete.mock.inspectFuncCanDelete = f

	return mmCanDelete
}

// Return sets up results that will be returned by UserService.CanDelete
func (mmCanDelete *mUserServiceMockCanDelete) Return(b1 bool) *UserServiceMock {
	if mmCanDelete.mock.funcCanDelete != nil {
		mmCanDelete.mock.t.Fatalf("UserServiceMock.CanDelete mock is already set by Set")
	}

	if mmCanDelete.defaultExpectation == nil {
		mmCanDelete.defaultExpectation = &UserServiceMockCanDeleteExpectation{mock: mmCanDelete.mock}
	}
	mmCanDelete.defaultExpectation.results = &UserServiceMockCanDeleteResults{b1}
	return mmCanDelete.mock
}

// Set uses given function f to mock the UserService.CanDelete method
func (mmCanDelete *mUserServiceMockCanDelete) Set(f func(ctx context.Context, userID int64) (b1 bool)) *UserServiceMock {
	if mmCanDelete.defaultExpectation != nil {
		mmCanDelete.mock.t.Fatalf("Default expectation is already set for the UserService.CanDelete method")
	}

	if len(mmCanDelete.expectations) > 0 {
		mmCanDelete.mock.t.Fatalf("Some expectations are already set for the UserService.CanDelete method")
	}

	mmCanDelete.mock.funcCanDelete = f
	return mmCanDelete.mock
}

// When sets expectation for the UserService.CanDelete which will trigger the result defined by the following
// Then helper
func (mmCanDelete *mUserServiceMockCanDelete) When(ctx context.Context, userID int64) *UserServiceMockCanDeleteExpectation {
	if mmCanDelete.mock.funcCanDelete != nil {
		mmCanDelete.mock.t.Fatalf("UserServiceMock.CanDelete mock is already set by Set")
	}

	expectation := &UserServiceMockCanDeleteExpectation{
		mock:   mmCanDelete.mock,
		params: &UserServiceMockCanDeleteParams{ctx, userID},
	}
	mmCanDelete.expectations = append(mmCanDelete.expectations, expectation)
	return expectation
}

// Then sets up UserService.CanDelete return parameters for the expectation previously defined by the When method
func (e *UserServiceMockCanDeleteExpectation) Then(b1 bool) *UserServiceMock {
	e.results = &UserServiceMockCanDeleteResults{b1}
	return e.mock
}

// CanDelete implements usecases.UserService
func (mmCanDelete *UserServiceMock) CanDelete(ctx context.Context, userID int64) (b1 bool) {
	mm_atomic.AddUint64(&mmCanDelete.beforeCanDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmCanDelete.afterCanDeleteCounter, 1)

	if mmCanDelete.inspectFuncCanDelete != nil {
		mmCanDelete.inspectFuncCanDelete(ctx, userID)
	}

	mm_params := UserServiceMockCanDeleteParams{ctx, userID}

	// Record call args
	mmCanDelete.CanDeleteMock.mutex.Lock()
	mmCanDelete.CanDeleteMock.callArgs = append(mmCanDelete.CanDeleteMock.callArgs, &mm_params)
	mmCanDelete.CanDeleteMock.mutex.Unlock()

	for _, e := range mmCanDelete.CanDeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmCanDelete.CanDeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCanDelete.CanDeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmCanDelete.CanDeleteMock.defaultExpectation.params
		mm_got := UserServiceMockCanDeleteParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCanDelete.t.Errorf("UserServiceMock.CanDelete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCanDelete.CanDeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmCanDelete.t.Fatal("No results are set for the UserServiceMock.CanDelete")
		}
		return (*mm_results).b1
	}
	if mmCanDelete.funcCanDelete != nil {
		return mmCanDelete.funcCanDelete(ctx, userID)
	}
	mmCanDelete.t.Fatalf("Unexpected call to UserServiceMock.CanDelete. %v %v", ctx, userID)
	return
}

// CanDeleteAfterCounter returns a count of finished UserServiceMock.CanDelete invocations
func (mmCanDelete *UserServiceMock) CanDeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCanDelete.afterCanDeleteCounter)
}

// CanDeleteBeforeCounter returns a count of UserServiceMock.CanDelete invocations
func (mmCanDelete *UserServiceMock) CanDeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCanDelete.beforeCanDeleteCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.CanDelete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCanDelete *mUserServiceMockCanDelete) Calls() []*UserServiceMockCanDeleteParams {
	mmCanDelete.mutex.RLock()

	argCopy := make([]*UserServiceMockCanDeleteParams, len(mmCanDelete.callArgs))
	copy(argCopy, mmCanDelete.callArgs)

	mmCanDelete.mutex.RUnlock()

	return argCopy
}

// MinimockCanDeleteDone returns true if the count of the CanDelete invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockCanDeleteDone() bool {
	for _, e := range m.CanDeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CanDeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCanDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCanDelete != nil && mm_atomic.LoadUint64(&m.afterCanDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockCanDeleteInspect logs each unmet expectation
func (m *UserServiceMock) MinimockCanDeleteInspect() {
	for _, e := range m.CanDeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.CanDelete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CanDeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCanDeleteCounter) < 1 {
		if m.CanDeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.CanDelete")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.CanDelete with params: %#v", *m.CanDeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCanDelete != nil && mm_atomic.LoadUint64(&m.afterCanDeleteCounter) < 1 {
		m.t.Error("Expected call to UserServiceMock.CanDelete")
	}
}

type mUserServiceMockCreate struct {
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockCreateExpectation
	expectations       []*UserServiceMockCreateExpectation

	callArgs []*UserServiceMockCreateParams
	mutex    sync.RWMutex
}

// UserServiceMockCreateExpectation specifies expectation struct of the UserService.Create
type UserServiceMockCreateExpectation struct {
	mock    *UserServiceMock
	params  *UserServiceMockCreateParams
	results *UserServiceMockCreateResults
	Counter uint64
}

// UserServiceMockCreateParams contains parameters of the UserService.Create
type UserServiceMockCreateParams struct {
	ctx context.Context
	req def.CreateDTO
}

// UserServiceMockCreateResults contains results of the UserService.Create
type UserServiceMockCreateResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for UserService.Create
func (mmCreate *mUserServiceMockCreate) Expect(ctx context.Context, req def.CreateDTO) *mUserServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserServiceMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &UserServiceMockCreateParams{ctx, req}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the UserService.Create
func (mmCreate *mUserServiceMockCreate) Inspect(f func(ctx context.Context, req def.CreateDTO)) *mUserServiceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by UserService.Create
func (mmCreate *mUserServiceMockCreate) Return(i1 int64, err error) *UserServiceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserServiceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &UserServiceMockCreateResults{i1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the UserService.Create method
func (mmCreate *mUserServiceMockCreate) Set(f func(ctx context.Context, req def.CreateDTO) (i1 int64, err error)) *UserServiceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the UserService.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the UserService.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the UserService.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mUserServiceMockCreate) When(ctx context.Context, req def.CreateDTO) *UserServiceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserServiceMock.Create mock is already set by Set")
	}

	expectation := &UserServiceMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &UserServiceMockCreateParams{ctx, req},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up UserService.Create return parameters for the expectation previously defined by the When method
func (e *UserServiceMockCreateExpectation) Then(i1 int64, err error) *UserServiceMock {
	e.results = &UserServiceMockCreateResults{i1, err}
	return e.mock
}

// Create implements usecases.UserService
func (mmCreate *UserServiceMock) Create(ctx context.Context, req def.CreateDTO) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, req)
	}

	mm_params := UserServiceMockCreateParams{ctx, req}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := UserServiceMockCreateParams{ctx, req}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("UserServiceMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the UserServiceMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, req)
	}
	mmCreate.t.Fatalf("Unexpected call to UserServiceMock.Create. %v %v", ctx, req)
	return
}

// CreateAfterCounter returns a count of finished UserServiceMock.Create invocations
func (mmCreate *UserServiceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of UserServiceMock.Create invocations
func (mmCreate *UserServiceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mUserServiceMockCreate) Calls() []*UserServiceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*UserServiceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *UserServiceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.Create")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to UserServiceMock.Create")
	}
}

type mUserServiceMockDelete struct {
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockDeleteExpectation
	expectations       []*UserServiceMockDeleteExpectation

	callArgs []*UserServiceMockDeleteParams
	mutex    sync.RWMutex
}

// UserServiceMockDeleteExpectation specifies expectation struct of the UserService.Delete
type UserServiceMockDeleteExpectation struct {
	mock    *UserServiceMock
	params  *UserServiceMockDeleteParams
	results *UserServiceMockDeleteResults
	Counter uint64
}

// UserServiceMockDeleteParams contains parameters of the UserService.Delete
type UserServiceMockDeleteParams struct {
	ctx    context.Context
	userID int64
}

// UserServiceMockDeleteResults contains results of the UserService.Delete
type UserServiceMockDeleteResults struct {
	err error
}

// Expect sets up expected params for UserService.Delete
func (mmDelete *mUserServiceMockDelete) Expect(ctx context.Context, userID int64) *mUserServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserServiceMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &UserServiceMockDeleteParams{ctx, userID}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the UserService.Delete
func (mmDelete *mUserServiceMockDelete) Inspect(f func(ctx context.Context, userID int64)) *mUserServiceMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by UserService.Delete
func (mmDelete *mUserServiceMockDelete) Return(err error) *UserServiceMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserServiceMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &UserServiceMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the UserService.Delete method
func (mmDelete *mUserServiceMockDelete) Set(f func(ctx context.Context, userID int64) (err error)) *UserServiceMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the UserService.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the UserService.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the UserService.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mUserServiceMockDelete) When(ctx context.Context, userID int64) *UserServiceMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserServiceMock.Delete mock is already set by Set")
	}

	expectation := &UserServiceMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &UserServiceMockDeleteParams{ctx, userID},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up UserService.Delete return parameters for the expectation previously defined by the When method
func (e *UserServiceMockDeleteExpectation) Then(err error) *UserServiceMock {
	e.results = &UserServiceMockDeleteResults{err}
	return e.mock
}

// Delete implements usecases.UserService
func (mmDelete *UserServiceMock) Delete(ctx context.Context, userID int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, userID)
	}

	mm_params := UserServiceMockDeleteParams{ctx, userID}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := UserServiceMockDeleteParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("UserServiceMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the UserServiceMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, userID)
	}
	mmDelete.t.Fatalf("Unexpected call to UserServiceMock.Delete. %v %v", ctx, userID)
	return
}

// DeleteAfterCounter returns a count of finished UserServiceMock.Delete invocations
func (mmDelete *UserServiceMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of UserServiceMock.Delete invocations
func (mmDelete *UserServiceMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mUserServiceMockDelete) Calls() []*UserServiceMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*UserServiceMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *UserServiceMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.Delete")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to UserServiceMock.Delete")
	}
}

type mUserServiceMockGet struct {
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockGetExpectation
	expectations       []*UserServiceMockGetExpectation

	callArgs []*UserServiceMockGetParams
	mutex    sync.RWMutex
}

// UserServiceMockGetExpectation specifies expectation struct of the UserService.Get
type UserServiceMockGetExpectation struct {
	mock    *UserServiceMock
	params  *UserServiceMockGetParams
	results *UserServiceMockGetResults
	Counter uint64
}

// UserServiceMockGetParams contains parameters of the UserService.Get
type UserServiceMockGetParams struct {
	ctx    context.Context
	userID int64
}

// UserServiceMockGetResults contains results of the UserService.Get
type UserServiceMockGetResults struct {
	u1  def.UserDTO
	err error
}

// Expect sets up expected params for UserService.Get
func (mmGet *mUserServiceMockGet) Expect(ctx context.Context, userID int64) *mUserServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserServiceMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &UserServiceMockGetParams{ctx, userID}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the UserService.Get
func (mmGet *mUserServiceMockGet) Inspect(f func(ctx context.Context, userID int64)) *mUserServiceMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by UserService.Get
func (mmGet *mUserServiceMockGet) Return(u1 def.UserDTO, err error) *UserServiceMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserServiceMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &UserServiceMockGetResults{u1, err}
	return mmGet.mock
}

// Set uses given function f to mock the UserService.Get method
func (mmGet *mUserServiceMockGet) Set(f func(ctx context.Context, userID int64) (u1 def.UserDTO, err error)) *UserServiceMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the UserService.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the UserService.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the UserService.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mUserServiceMockGet) When(ctx context.Context, userID int64) *UserServiceMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserServiceMock.Get mock is already set by Set")
	}

	expectation := &UserServiceMockGetExpectation{
		mock:   mmGet.mock,
		params: &UserServiceMockGetParams{ctx, userID},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up UserService.Get return parameters for the expectation previously defined by the When method
func (e *UserServiceMockGetExpectation) Then(u1 def.UserDTO, err error) *UserServiceMock {
	e.results = &UserServiceMockGetResults{u1, err}
	return e.mock
}

// Get implements usecases.UserService
func (mmGet *UserServiceMock) Get(ctx context.Context, userID int64) (u1 def.UserDTO, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, userID)
	}

	mm_params := UserServiceMockGetParams{ctx, userID}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := UserServiceMockGetParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("UserServiceMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the UserServiceMock.Get")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, userID)
	}
	mmGet.t.Fatalf("Unexpected call to UserServiceMock.Get. %v %v", ctx, userID)
	return
}

// GetAfterCounter returns a count of finished UserServiceMock.Get invocations
func (mmGet *UserServiceMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of UserServiceMock.Get invocations
func (mmGet *UserServiceMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mUserServiceMockGet) Calls() []*UserServiceMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*UserServiceMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *UserServiceMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.Get")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to UserServiceMock.Get")
	}
}

type mUserServiceMockRenewal struct {
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockRenewalExpectation
	expectations       []*UserServiceMockRenewalExpectation

	callArgs []*UserServiceMockRenewalParams
	mutex    sync.RWMutex
}

// UserServiceMockRenewalExpectation specifies expectation struct of the UserService.Renewal
type UserServiceMockRenewalExpectation struct {
	mock    *UserServiceMock
	params  *UserServiceMockRenewalParams
	results *UserServiceMockRenewalResults
	Counter uint64
}

// UserServiceMockRenewalParams contains parameters of the UserService.Renewal
type UserServiceMockRenewalParams struct {
	ctx           context.Context
	refreshToken  string
	isRenewAccess bool
}

// UserServiceMockRenewalResults contains results of the UserService.Renewal
type UserServiceMockRenewalResults struct {
	s1  string
	err error
}

// Expect sets up expected params for UserService.Renewal
func (mmRenewal *mUserServiceMockRenewal) Expect(ctx context.Context, refreshToken string, isRenewAccess bool) *mUserServiceMockRenewal {
	if mmRenewal.mock.funcRenewal != nil {
		mmRenewal.mock.t.Fatalf("UserServiceMock.Renewal mock is already set by Set")
	}

	if mmRenewal.defaultExpectation == nil {
		mmRenewal.defaultExpectation = &UserServiceMockRenewalExpectation{}
	}

	mmRenewal.defaultExpectation.params = &UserServiceMockRenewalParams{ctx, refreshToken, isRenewAccess}
	for _, e := range mmRenewal.expectations {
		if minimock.Equal(e.params, mmRenewal.defaultExpectation.params) {
			mmRenewal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRenewal.defaultExpectation.params)
		}
	}

	return mmRenewal
}

// Inspect accepts an inspector function that has same arguments as the UserService.Renewal
func (mmRenewal *mUserServiceMockRenewal) Inspect(f func(ctx context.Context, refreshToken string, isRenewAccess bool)) *mUserServiceMockRenewal {
	if mmRenewal.mock.inspectFuncRenewal != nil {
		mmRenewal.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Renewal")
	}

	mmRenewal.mock.inspectFuncRenewal = f

	return mmRenewal
}

// Return sets up results that will be returned by UserService.Renewal
func (mmRenewal *mUserServiceMockRenewal) Return(s1 string, err error) *UserServiceMock {
	if mmRenewal.mock.funcRenewal != nil {
		mmRenewal.mock.t.Fatalf("UserServiceMock.Renewal mock is already set by Set")
	}

	if mmRenewal.defaultExpectation == nil {
		mmRenewal.defaultExpectation = &UserServiceMockRenewalExpectation{mock: mmRenewal.mock}
	}
	mmRenewal.defaultExpectation.results = &UserServiceMockRenewalResults{s1, err}
	return mmRenewal.mock
}

// Set uses given function f to mock the UserService.Renewal method
func (mmRenewal *mUserServiceMockRenewal) Set(f func(ctx context.Context, refreshToken string, isRenewAccess bool) (s1 string, err error)) *UserServiceMock {
	if mmRenewal.defaultExpectation != nil {
		mmRenewal.mock.t.Fatalf("Default expectation is already set for the UserService.Renewal method")
	}

	if len(mmRenewal.expectations) > 0 {
		mmRenewal.mock.t.Fatalf("Some expectations are already set for the UserService.Renewal method")
	}

	mmRenewal.mock.funcRenewal = f
	return mmRenewal.mock
}

// When sets expectation for the UserService.Renewal which will trigger the result defined by the following
// Then helper
func (mmRenewal *mUserServiceMockRenewal) When(ctx context.Context, refreshToken string, isRenewAccess bool) *UserServiceMockRenewalExpectation {
	if mmRenewal.mock.funcRenewal != nil {
		mmRenewal.mock.t.Fatalf("UserServiceMock.Renewal mock is already set by Set")
	}

	expectation := &UserServiceMockRenewalExpectation{
		mock:   mmRenewal.mock,
		params: &UserServiceMockRenewalParams{ctx, refreshToken, isRenewAccess},
	}
	mmRenewal.expectations = append(mmRenewal.expectations, expectation)
	return expectation
}

// Then sets up UserService.Renewal return parameters for the expectation previously defined by the When method
func (e *UserServiceMockRenewalExpectation) Then(s1 string, err error) *UserServiceMock {
	e.results = &UserServiceMockRenewalResults{s1, err}
	return e.mock
}

// Renewal implements usecases.UserService
func (mmRenewal *UserServiceMock) Renewal(ctx context.Context, refreshToken string, isRenewAccess bool) (s1 string, err error) {
	mm_atomic.AddUint64(&mmRenewal.beforeRenewalCounter, 1)
	defer mm_atomic.AddUint64(&mmRenewal.afterRenewalCounter, 1)

	if mmRenewal.inspectFuncRenewal != nil {
		mmRenewal.inspectFuncRenewal(ctx, refreshToken, isRenewAccess)
	}

	mm_params := UserServiceMockRenewalParams{ctx, refreshToken, isRenewAccess}

	// Record call args
	mmRenewal.RenewalMock.mutex.Lock()
	mmRenewal.RenewalMock.callArgs = append(mmRenewal.RenewalMock.callArgs, &mm_params)
	mmRenewal.RenewalMock.mutex.Unlock()

	for _, e := range mmRenewal.RenewalMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmRenewal.RenewalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRenewal.RenewalMock.defaultExpectation.Counter, 1)
		mm_want := mmRenewal.RenewalMock.defaultExpectation.params
		mm_got := UserServiceMockRenewalParams{ctx, refreshToken, isRenewAccess}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRenewal.t.Errorf("UserServiceMock.Renewal got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRenewal.RenewalMock.defaultExpectation.results
		if mm_results == nil {
			mmRenewal.t.Fatal("No results are set for the UserServiceMock.Renewal")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmRenewal.funcRenewal != nil {
		return mmRenewal.funcRenewal(ctx, refreshToken, isRenewAccess)
	}
	mmRenewal.t.Fatalf("Unexpected call to UserServiceMock.Renewal. %v %v %v", ctx, refreshToken, isRenewAccess)
	return
}

// RenewalAfterCounter returns a count of finished UserServiceMock.Renewal invocations
func (mmRenewal *UserServiceMock) RenewalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenewal.afterRenewalCounter)
}

// RenewalBeforeCounter returns a count of UserServiceMock.Renewal invocations
func (mmRenewal *UserServiceMock) RenewalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenewal.beforeRenewalCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Renewal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRenewal *mUserServiceMockRenewal) Calls() []*UserServiceMockRenewalParams {
	mmRenewal.mutex.RLock()

	argCopy := make([]*UserServiceMockRenewalParams, len(mmRenewal.callArgs))
	copy(argCopy, mmRenewal.callArgs)

	mmRenewal.mutex.RUnlock()

	return argCopy
}

// MinimockRenewalDone returns true if the count of the Renewal invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockRenewalDone() bool {
	for _, e := range m.RenewalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RenewalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRenewalCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRenewal != nil && mm_atomic.LoadUint64(&m.afterRenewalCounter) < 1 {
		return false
	}
	return true
}

// MinimockRenewalInspect logs each unmet expectation
func (m *UserServiceMock) MinimockRenewalInspect() {
	for _, e := range m.RenewalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Renewal with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RenewalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRenewalCounter) < 1 {
		if m.RenewalMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.Renewal")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Renewal with params: %#v", *m.RenewalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRenewal != nil && mm_atomic.LoadUint64(&m.afterRenewalCounter) < 1 {
		m.t.Error("Expected call to UserServiceMock.Renewal")
	}
}

type mUserServiceMockUpdate struct {
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockUpdateExpectation
	expectations       []*UserServiceMockUpdateExpectation

	callArgs []*UserServiceMockUpdateParams
	mutex    sync.RWMutex
}

// UserServiceMockUpdateExpectation specifies expectation struct of the UserService.Update
type UserServiceMockUpdateExpectation struct {
	mock    *UserServiceMock
	params  *UserServiceMockUpdateParams
	results *UserServiceMockUpdateResults
	Counter uint64
}

// UserServiceMockUpdateParams contains parameters of the UserService.Update
type UserServiceMockUpdateParams struct {
	ctx  context.Context
	user def.UpdateDTO
}

// UserServiceMockUpdateResults contains results of the UserService.Update
type UserServiceMockUpdateResults struct {
	err error
}

// Expect sets up expected params for UserService.Update
func (mmUpdate *mUserServiceMockUpdate) Expect(ctx context.Context, user def.UpdateDTO) *mUserServiceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserServiceMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &UserServiceMockUpdateParams{ctx, user}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the UserService.Update
func (mmUpdate *mUserServiceMockUpdate) Inspect(f func(ctx context.Context, user def.UpdateDTO)) *mUserServiceMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by UserService.Update
func (mmUpdate *mUserServiceMockUpdate) Return(err error) *UserServiceMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserServiceMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &UserServiceMockUpdateResults{err}
	return mmUpdate.mock
}

// Set uses given function f to mock the UserService.Update method
func (mmUpdate *mUserServiceMockUpdate) Set(f func(ctx context.Context, user def.UpdateDTO) (err error)) *UserServiceMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the UserService.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the UserService.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the UserService.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mUserServiceMockUpdate) When(ctx context.Context, user def.UpdateDTO) *UserServiceMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserServiceMock.Update mock is already set by Set")
	}

	expectation := &UserServiceMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &UserServiceMockUpdateParams{ctx, user},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up UserService.Update return parameters for the expectation previously defined by the When method
func (e *UserServiceMockUpdateExpectation) Then(err error) *UserServiceMock {
	e.results = &UserServiceMockUpdateResults{err}
	return e.mock
}

// Update implements usecases.UserService
func (mmUpdate *UserServiceMock) Update(ctx context.Context, user def.UpdateDTO) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, user)
	}

	mm_params := UserServiceMockUpdateParams{ctx, user}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := UserServiceMockUpdateParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("UserServiceMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the UserServiceMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, user)
	}
	mmUpdate.t.Fatalf("Unexpected call to UserServiceMock.Update. %v %v", ctx, user)
	return
}

// UpdateAfterCounter returns a count of finished UserServiceMock.Update invocations
func (mmUpdate *UserServiceMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of UserServiceMock.Update invocations
func (mmUpdate *UserServiceMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mUserServiceMockUpdate) Calls() []*UserServiceMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*UserServiceMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *UserServiceMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.Update")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to UserServiceMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAuthInspect()

			m.MinimockCanDeleteInspect()

			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockRenewalInspect()

			m.MinimockUpdateInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAuthDone() &&
		m.MinimockCanDeleteDone() &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockRenewalDone() &&
		m.MinimockUpdateDone()
}
